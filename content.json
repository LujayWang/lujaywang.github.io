{"meta":{"title":"LujayWang's Blog","subtitle":"","description":"","author":"Lujay Wang","url":"https://LujayWang.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-09-02T10:37:10.487Z","updated":"2021-09-02T10:37:10.487Z","comments":false,"path":"/404.html","permalink":"https://lujaywang.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-02-28T14:12:50.358Z","updated":"2023-02-28T14:12:50.354Z","comments":false,"path":"about/index.html","permalink":"https://lujaywang.github.io/about/index.html","excerpt":"","text":"基本信息中文名：汪奇伟英文名：Lujay性 别：男年 龄：25城 市：杭州学 校：东华理工大学 专业技能 1.熟练掌握Java编程语言； 2.熟练掌握数据结构且对算法有一定的研究； 3.熟练掌握Spring、SpringMVC、SpringBoot、MyBatis等主流框架开发； 4.熟练掌握Redis、RabbitMQ消息队列等中间件； 5.熟练掌握MySQL关系型数据库语言及其索引优化； 6.熟练掌握 Linux 常用命令； 7.熟练掌握JUC并发编程; 8.了解 Spring Cloud及Spring Cloud Alibaba技术栈且有实际开发经验 ; 9.了解 Vue、React、JQuery等前端框架及其UI框架且有实际开发经验。 自我评价 乐观向上，平易近人，喜欢主动接触新知识，新事物。热爱coding，对软件开发技术充满兴趣。平常也爱看电影，打羽毛球。"},{"title":"书单","date":"2023-02-28T13:51:11.896Z","updated":"2021-09-02T10:37:10.546Z","comments":false,"path":"books/index.html","permalink":"https://lujaywang.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-02T10:37:10.578Z","updated":"2021-09-02T10:37:10.578Z","comments":false,"path":"categories/index.html","permalink":"https://lujaywang.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-09-02T10:37:10.605Z","updated":"2021-09-02T10:37:10.605Z","comments":true,"path":"links/index.html","permalink":"https://lujaywang.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-09-02T10:37:10.633Z","updated":"2021-09-02T10:37:10.633Z","comments":false,"path":"repository/index.html","permalink":"https://lujaywang.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-02T10:37:10.661Z","updated":"2021-09-02T10:37:10.661Z","comments":false,"path":"tags/index.html","permalink":"https://lujaywang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"bean生命周期","slug":"bean生命周期","date":"2023-02-28T15:11:00.000Z","updated":"2023-03-01T12:45:18.683Z","comments":true,"path":"2023/02/28/bean生命周期/","link":"","permalink":"https://lujaywang.github.io/2023/02/28/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"一、bean的生命周期bean的生命周期即bean从创建到销毁的全过程，但总体可以分为bean定义、实例化、属性填充、初始化（afterPropertiesSet）、生存期、销毁六个阶段。 二、图解bean的生命周期 bean定义：通过ComponentScan扫描类并生成BeanDefinition； 实例化bean：根据BeanDefinition生成对应的bean； 属性填充：依赖注入填充bean的属性值； 初始化：实现aware接口，设置对应的值 –&gt;调用InitializingBean的afterPropertiesSet方法 –&gt; 调用&lt; bean &gt;的 init-method方法； 生存期：执行BeanPostProccessor的postProcessAfterinitialization()方法 –&gt; 将单例bean存入单例池中 –&gt; 将bean给调用方使用； 销毁：调用DisposableBean的destory()方法（和InitializingBean对应）–&gt; 调用&lt; bean &gt;的destory-method方法。 注意：AOP(object orient program)的底层实现原理是通过实现BeanPostProcessor的postProcessAfterinitialization()方法，通过cglib的字节码增强器（Enhancer）生成bean的代理对象，经过AOP生成的bean是bean的代理对象和根据BeanDefinition实例化的bean是两个不同的对象，也就会导致事务传播机制中会存在同一个类中事务传播失效的问题（后续专门补充章节介绍）。 三、代码测试测试代码： OrderService.java 123@Componentpublic class OrderService &#123;&#125; UserService.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class UserService implements InitializingBean, DisposableBean, BeanNameAware &#123; public UserService() &#123; System.out.println(&quot;实例化bean&quot;); &#125; private String beanName; @Autowired private OrderService orderService; public void setBeanName(String s) &#123; this.beanName = beanName; System.out.println(&quot;调用Aware接口，设置容器属性&quot;); &#125; @PostConstruct public void postConstruct() &#123; System.out.println(&quot;调用@PostConstruct注解标注的方法&quot;); &#125; private void initMethod() &#123; System.out.println(&quot;调用&lt;bean&gt;配置的initMethod方法&quot;); &#125; public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;调用InitializingBean的afterPropertiesSet方法&quot;); &#125; @PreDestroy public void preDestroy() &#123; System.out.println(&quot;调用@PreDestroy注解标注的方法&quot;); &#125; public void destroy() throws Exception &#123; System.out.println(&quot;调用DisposableBean的destroy方法&quot;); &#125; private void destroyMethod() &#123; System.out.println(&quot;调用&lt;bean&gt;配置的destroyMethod方法&quot;); &#125;&#125; MyBeanPostProcessor.java 123456789101112@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;调用BeanPostProcessor的前置处理器&quot;); return bean; &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;调用BeanPostProcessor的后置处理器&quot;); return bean; &#125;&#125; SpringApplicationContext.java 123456789101112131415@Configuration@ComponentScan(&quot;com.lujay&quot;)public class SpringApplicationContext &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringApplicationContext.class); UserService userService = context.getBean(UserService.class); System.out.println(userService); context.close(); &#125; @Bean(initMethod = &quot;initMethod&quot;, destroyMethod = &quot;destroyMethod&quot;) public UserService getUserService() &#123; return new UserService(); &#125;&#125; 运行结果： 1234567891011实例化bean调用Aware接口，设置容器属性调用BeanPostProcessor的前置处理器调用@PostConstruct注解标注的方法调用InitializingBean的afterPropertiesSet方法调用&lt;bean&gt;配置的initMethod方法调用BeanPostProcessor的后置处理器com.lujay.UserService@11dc3715调用@PreDestroy注解标注的方法调用DisposableBean的destroy方法调用&lt;bean&gt;配置的destroyMethod方法","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"spring","slug":"后端开发/spring","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/spring/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://lujaywang.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"spring","slug":"spring","permalink":"https://lujaywang.github.io/tags/spring/"}]},{"title":"MySQL的事务隔离级别及脏读、幻读、不可重复读","slug":"MySQL的事务隔离级别及脏读-幻读-不可重复读","date":"2021-09-06T15:13:09.000Z","updated":"2021-09-24T09:44:16.122Z","comments":true,"path":"2021/09/06/MySQL的事务隔离级别及脏读-幻读-不可重复读/","link":"","permalink":"https://lujaywang.github.io/2021/09/06/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E8%84%8F%E8%AF%BB-%E5%B9%BB%E8%AF%BB-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/","excerpt":"","text":"一 数据库事务的隔离级别数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。 1. Read UnCommitted(读未提交)最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果。 2. Read Committed(读提交)大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。 3. Repeatable Read(重复读)mysql的默认级别。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。 4. Serializable(序列化)最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。 二 不同事务级别带来的并发问题1 脏读脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。这跟不可重复读类似，但是第二个事务不需要执行提交。 2 不可重复读在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题。 在上面这个例子中，事务2提交成功，它所做的修改已经可见。然而，事务1已经读取了一个其它的值。在序列化和可重复读的隔离级别中，数据库管理系统会返回旧值，即在被事务2修改之前的值。在提交读和未提交读隔离级别下，可能会返回被更新的值，这就是“不可重复读”。 有两个策略可以防止这个问题的发生： (1) 推迟事务2的执行，直至事务1提交或者回退。这种策略在使用锁时应用。 (2) 而在多版本并行控制中，事务2可以被先提交。而事务1，继续执行在旧版本的数据上。当事务1终于尝试提交时，数据库会检验它的结果是否和事务1、事务2顺序执行时一样。如果是，则事务1提交成功。如果不是，事务1会被回退。 3 幻读 幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。 发生的条件：没有范围锁。 三 例子比较不可重复读和幻读1 不可重复读不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 例子: 在事务1中，Mary 读取了自己的工资为1000,操作并没有完成 12con1 = getConnection(); select salary from employee empId =&quot;Mary&quot;; 在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务. 123con2 = getConnection(); update employee set salary = 2000; con2.commit(); 在事务1中，Mary 再次读取自己的工资时，工资变为了2000 1select salary from employee empId =&quot;Mary&quot;; 在一个事务中前后两次读取的结果并不致，导致了不可重复读。 2 幻读幻读的重点在于新增或者删除 (数据条数变化)。同样的条件, 第1次和第2次读出来的记录数不一样 例子： 目前工资为1000的员工有10人。事务1,读取所有工资为1000的员工。 12con1 = getConnection(); Select * from employee where salary =1000; 共读取10条记录 这时另一个事务向employee表插入了一条员工记录，工资也为1000 123con2 = getConnection(); Insert into employee(empId,salary) values(&quot;Lili&quot;,1000); con2.commit(); 事务1再次读取所有工资为1000的员工 1select * from employee where salary =1000; 共读取到了11条记录，这就像产生了幻读。","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"后端开发/数据库","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lujaywang.github.io/tags/MySQL/"},{"name":"后端","slug":"后端","permalink":"https://lujaywang.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Redis学习笔记","slug":"Redis学习笔记","date":"2021-09-05T06:21:03.000Z","updated":"2023-02-28T13:48:37.481Z","comments":true,"path":"2021/09/05/Redis学习笔记/","link":"","permalink":"https://lujaywang.github.io/2021/09/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"❝ Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。本文Redis相关命令基于Linux CentOs 8系统 ❞ 一、如何将redis在后台启动？ 将redis的配置文件redis.conf的daemonize设置为yes再启动即可；也可以拷贝redis.conf文件，然后在修改拷贝的文件，redis-server 拷贝后文件地址命令指定新的配置文件地址。 二、redis压力测试1$ redis-benchmark -h 127.0.0.1 -p 6379 -c 50 -n 10000 三、Linux远程服务器上的redis怎么在本地通过可视化软件(Medis, Redist Manager Desktop)进行连接访问？ 1）去服务器安全组将对应的端口号放开 2）将端口的防火墙打开，并重启防火墙 ​ firewall-cmd –permanent –add-port=6379/tcp ​ firwall-cmd –reload 或者 systemctl restart firewalld.service 3）还是不行的，查看redis配置文件上的bind 127.0.0.1是否注释掉，protected-mode是否设置为no 四、常用命令1234567891011121314151617181920212223242526272829303132333435[root@LujayWang bin]# redis-cli -p 6379 #进入redis客户端127.0.0.1:6379&gt; ping #判断是否连接成功PONG127.0.0.1:6379&gt; select 1 #选择redis数据库，一共有16个，从0开始OK127.0.0.1:6379[1]&gt; set name &quot;wangqiwei&quot; #redis是以key-value键值对进行存储的，设置key为name的值为&quot;wangqiwei&quot;OK127.0.0.1:6379[1]&gt; get name #获取key值为name的值&quot;wangqiwei&quot;127.0.0.1:6379[1]&gt; keys * #查看所有键1) &quot;name&quot;127.0.0.1:6379[1]&gt; select 0 #第0号数据库为默认数据库OK127.0.0.1:6379&gt; flushdb #清空当前数据库的数据OK127.0.0.1:6379&gt; flushall #清空所有数据库的数据OK 127.0.0.1:6379&gt; keys * #查看所有键(empty list or set)127.0.0.1:6379&gt; set name wangqiweiOK127.0.0.1:6379&gt; type name #查看某个key值的数据类型string127.0.0.1:6379&gt; exists name #查看是否有存在名字为name的key，有返回1，没有返回0(integer) 1127.0.0.1:6379&gt; exists name1(integer) 0127.0.0.1:6379&gt; expire name 10 #设置name的过期时间为10s(integer) 1127.0.0.1:6379&gt; ttl name #查看key还有多久过期，整数表示还剩多少s过期，负数表示已过期(integer) 5127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; keys *(empty list or set) 注意：Redis是单线程的！ 五、Redis数据类型1.String字符串类型1）常用字符串操作123456789101112131415161718192021################################127.0.0.1:6379&gt; flushdb OK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set key1 helloOK127.0.0.1:6379&gt; get key1&quot;hello&quot;127.0.0.1:6379&gt; append key1 ,redis #向key1中追加字符串，返回值追加后的字符串长度(integer) 11127.0.0.1:6379&gt; get key1&quot;hello,redis&quot;127.0.0.1:6379&gt; strlen key1 #获取key1字符串的长度(integer) 11127.0.0.1:6379&gt; append key2 lujaywang #如果append的key不存在，则会创建该key，值为追加的字符(integer) 9127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot;################################## 2）操作数值型数据12345678910111213141516171819202122232425262728##################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set value 0OK127.0.0.1:6379&gt; get value&quot;0&quot;127.0.0.1:6379&gt; type value #redis中的数值还是以字符串形式存储的，但不影响对其进行操作string127.0.0.1:6379&gt; incr value #对value的值加一，类似i++(integer) 1127.0.0.1:6379&gt; incr value(integer) 2127.0.0.1:6379&gt; decr value #对value的值减一，累死(integer) 1127.0.0.1:6379&gt; decr value(integer) 0127.0.0.1:6379&gt; incrby value 10 #对value的值加10，最后一个参数为步长，类似i += 10(integer) 10127.0.0.1:6379&gt; incrby value 10(integer) 20127.0.0.1:6379&gt; decrby value 10 #对value的值减10，最后一个参数为步长，累死i -= 10(integer) 10127.0.0.1:6379&gt; decrby value 10(integer) 0#################################### 3）字符操作扩展123456789101112131415161718####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set str hello,redisOK127.0.0.1:6379&gt; get str&quot;hello,redis&quot;127.0.0.1:6379&gt; getrange str 1 3 #获取字符串索引1到3的字符串，类似于java中substring操作&quot;ell&quot;127.0.0.1:6379&gt; getrange str 0 -1 #获取全部字符串，-1代表最后&quot;hello,redis&quot;127.0.0.1:6379&gt; setrange str 1 haha #将索引为1后面的&#x27;haha&#x27;长度字符串替换为&#x27;haha&#x27;，类似于java中replace操作(integer) 11127.0.0.1:6379&gt; get str&quot;hhaha,redis&quot;#################################### 4）设置获取字符串扩展1234567891011121314151617181920212223242526####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; setex key1 15 hahahaha #set expire合并简写，创建key:value并设置过期时间,如果key已存在则修改值并设置过期时间OK127.0.0.1:6379&gt; get key1&quot;hahahaha&quot;127.0.0.1:6379&gt; ttl key1(integer) 7127.0.0.1:6379&gt; ttl key1(integer) -2127.0.0.1:6379&gt; get key1(nil)127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; setnx key2 xixixi #set if not exit简写，如果不存在就创建key:value,存在就不会进行创建和修改值(integer) 1127.0.0.1:6379&gt; get key2&quot;xixixi&quot;127.0.0.1:6379&gt; setnx key2 hehehe(integer) 0127.0.0.1:6379&gt; get key2&quot;xixixi&quot;#################################### 5）组合操作12345678910111213141516171819202122####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; mset key1 a key2 b key3 c #同时对key1,key2,key3进行赋值OK127.0.0.1:6379&gt; mget key1 key2 key3 #同时获取key1,key2,key3的值1) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;127.0.0.1:6379&gt; msetnx key1 d key4 d #如果key1,key4都不存在，则设置key1,key4的值；有一个存在，则都不进行设置；具有原子性，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379&gt; mget key1 key41) &quot;a&quot;2) (nil)127.0.0.1:6379&gt; msetnx key4 3 key5 2(integer) 1127.0.0.1:6379&gt; mget key4 key51) &quot;3&quot;2) &quot;2&quot;#################################### 6）对象操作1234567891011####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set user &quot;&#123;name:&#x27;wangqiwei&#x27;,age:18&#125;&quot; #设置json字符串的方式OK127.0.0.1:6379&gt; set user:name wangqiwei #设置key值的方式分别设置，单个字段或者字段不多的情况下推荐使用OK127.0.0.1:6379&gt; set user:age 18 #设置key值的方式分别设置OK 2.List列表类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081######################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; lpush list1 b c d #创建list1列表初始化为b,c,d(integer) 3127.0.0.1:6379&gt; lrange list1 0 -1 #查看数据，（0，-1）表示全部数据1) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;127.0.0.1:6379&gt; lpush list1 a #左边插入一条数据a(integer) 4127.0.0.1:6379&gt; lrange list1 0 -11) &quot;a&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;127.0.0.1:6379&gt; rpush list1 e #右边插入数据e(integer) 5127.0.0.1:6379&gt; lrange list1 0 -11) &quot;a&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;5) &quot;e&quot;127.0.0.1:6379&gt; lpop list1 #左边删除一条数据，最后可以加一个数字代表删除多少条，没有默认一条&quot;a&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;e&quot;127.0.0.1:6379&gt; rpop list1 #右边删除一条数据，最后可以加一个数字代表删除多少条，没有默认一条&quot;e&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;127.0.0.1:6379&gt; llen list1 #获取列表长度(integer) 3127.0.0.1:6379&gt; lset list1 1 f #修改索引为1(从0开始)的值为f，列表必须存在且不能越界否则会报错 OK127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;f&quot;3) &quot;b&quot;127.0.0.1:6379&gt; rpoplpush list1 list2 #list右边第一条数据删除并将这条数据从左边推入到list2中&quot;b&quot;127.0.0.1:6379&gt; lrange list2 0 0 1) &quot;b&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;f&quot;127.0.0.1:6379&gt; lrem list1 1 d #删除list1中一条值为d的数据(integer) 1127.0.0.1:6379&gt; lrange list1 0 -11) &quot;f&quot;127.0.0.1:6379&gt; linsert list1 before f a #在list1的第一个值为f的前面插入一条数据啊(integer) 2127.0.0.1:6379&gt; lrange list1 0 -11) &quot;a&quot;2) &quot;f&quot;127.0.0.1:6379&gt; lpush list1 b c d e(integer) 6127.0.0.1:6379&gt; lrange list1 0 -11) &quot;e&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;5) &quot;a&quot;6) &quot;f&quot;127.0.0.1:6379&gt; ltrim list1 2 4 #将list1的数据进行裁剪，保留索引为2到4之间的数据OK127.0.0.1:6379&gt; lrange list1 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; exists list1 #判断列表是否存在(integer) 1127.0.0.1:6379&gt; lindex list1 1 #获取索引值为1的数据 &quot;f&quot;########################################## 总结： 增加数据：lpush、rpush、linsert、rpoplpush 删除数据：lpop、rpop、ltrim、lrem、rpoplpush 修改数据：lset 查看数据：lrange、lindex 查看长度：llen 判断是否存在：exists 3.Set集合类型1234567891011121314151617181920212223242526272829303132333435363738394041424344##########################################127.0.0.1:6379&gt; sadd myset hello world redis #创建myset并向其中添加元素(integer) 3127.0.0.1:6379&gt; smembers myset #查看set的元素1) &quot;world&quot;2) &quot;redis&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; sismember myset hello #判断某个值是否为set的元素(integer) 1127.0.0.1:6379&gt; scard myset #查看set的长度(integer) 3127.0.0.1:6379&gt; srem myset hello #删除set中的某一个元素(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;world&quot;2) &quot;redis&quot;127.0.0.1:6379&gt; srandmember myset #随机查看set中的一个元素,后面可以加数字，查看随机几个元素&quot;world&quot;127.0.0.1:6379&gt; srandmember myset&quot;redis&quot;127.0.0.1:6379&gt; spop myset #随机删除set中的一个元素&quot;world&quot;127.0.0.1:6379&gt; smove myset myset2 redis #将myset中的一个元素移到myset2中，myset2不存在就自动创建(integer) 1127.0.0.1:6379&gt; smembers myset(empty array)127.0.0.1:6379&gt; smembers myset21) &quot;redis&quot;127.0.0.1:6379&gt; sadd key1 a b c(integer) 3127.0.0.1:6379&gt; sadd key2 c d e(integer) 3127.0.0.1:6379&gt; sdiff key1 key2 #key1中存在，key2中不存在的元素，差集1) &quot;b&quot;2) &quot;a&quot;127.0.0.1:6379&gt; sinter key1 key2 #交集1) &quot;c&quot;127.0.0.1:6379&gt; sunion key1 key2 #并集1) &quot;a&quot;2) &quot;e&quot;3) &quot;c&quot;4) &quot;b&quot;5) &quot;d&quot;######################################### 总结： sadd：创建并新增元素 smembers：查看set里面的元素 sismember：查看某个值是否为set中的元素 srem：删除指定的元素 srandmember：获取随机一个或者几个元素 spop：随机删除一个元素 smove：移动一个set中的元素到另一个set中 sdiff：查看两个set的差集 sinter：查看两个set的交集 sunion：查看两个set的并集 4.Hash哈希类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152############################################127.0.0.1:6379&gt; hset myhash field1 a field2 b #新建hash并初始化(integer) 2127.0.0.1:6379&gt; hget myhash field1 #获取hash中的某一个值&quot;a&quot;127.0.0.1:6379&gt; hmget myhash field1 field2 #获取hash中的几个键值1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379&gt; hmset myhash field1 c fied3 d #批量设置属性值OK127.0.0.1:6379&gt; hgetall myhash #获取所有值1) &quot;field1&quot;2) &quot;c&quot;3) &quot;field2&quot;4) &quot;b&quot;5) &quot;fied3&quot;6) &quot;d&quot;127.0.0.1:6379&gt; hdel myhash field1 #删除hash中的某一个键值(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;b&quot;3) &quot;fied3&quot;4) &quot;d&quot;127.0.0.1:6379&gt; hlen myhash #获取hash的长度(integer) 2127.0.0.1:6379&gt; hexists myhash field2 #判断hash是否存在某一个键(integer) 1127.0.0.1:6379&gt; hkeys myhash #获取hash的所有键1) &quot;field2&quot;2) &quot;fied3&quot;127.0.0.1:6379&gt; hvals myhash #获取hash的所有值1) &quot;b&quot;2) &quot;d&quot;127.0.0.1:6379&gt; hset myhash field4 5 (integer) 1127.0.0.1:6379&gt; hincrby myhash field4 1 #将键值+1(integer) 6127.0.0.1:6379&gt; hincrby myhash field4 -1 #将键值-1(integer) 5127.0.0.1:6379&gt; hsetnx myhash field5 d #不存在就添加键和值(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;b&quot;3) &quot;fied3&quot;4) &quot;d&quot;5) &quot;field4&quot;6) &quot;5&quot;7) &quot;field5&quot;8) &quot;d&quot;########################################### 总结： hset：创建并初始化值或者修改键值 hmset：功能与hset一致 hmget：同时获取hash多个键的值 hget：获取hash某个键的值 hgetall：获取hash所有的键值 hdel：删除hash某个键 hlen：获取hash长度 hexists：判断hash是否存在键 hkeys：获取hash所有键 hvals：获取hash所有值 hincrby：将hash的一个数值的键值+1，如果为负数则减一 hsetnx：如果不存在就向hash添加键值 5.Zset有序集合类型123456789101112131415161718192021222324252627282930127.0.0.1:6379&gt; zadd myset 1 one #创建并初始化zset或添加元素(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three(integer) 2127.0.0.1:6379&gt; zrange myset 0 -1 #查看所有元素1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;127.0.0.1:6379&gt; zadd myset 10 ten(integer) 1127.0.0.1:6379&gt; zrangebyscore myset -inf +inf #获取根据score增序排列zset1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;4) &quot;ten&quot;127.0.0.1:6379&gt; zrange myset 0 -1 1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;4) &quot;ten&quot;127.0.0.1:6379&gt; zrem myset ten #删除zset中的某一个元素(integer) 1127.0.0.1:6379&gt; zcard myset #查看zset的长度(integer) 3127.0.0.1:6379&gt; zrevrange myset 0 -1 #获取根据score降序排列的zset1) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; zcount myset 2 3 #查看zset中score在两个数值之间的个数(integer) 2 总结： zadd：创建并初始化zset或添加元素 zrange：获取zset所有元素 zrangebyscore：根据score对zset进行增序排序，可以通过limit显示一部分，withscore显示score值 zrevrange：根据score对zset进行降序排列并显示 zcount：获取zset元素在score两个数值之间的个数 zcard：获取zset的长度 zrem：删除zset中某个元素 6.Geospatial地理位置7.Hyperloglog基数统计8.Bitmap位图场景","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"后端开发/数据库","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://lujaywang.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"redis","slug":"redis","permalink":"https://lujaywang.github.io/tags/redis/"},{"name":"noSql","slug":"noSql","permalink":"https://lujaywang.github.io/tags/noSql/"}]},{"title":"Linux常用命令大全","slug":"Linux常用命令大全","date":"2021-09-04T06:07:29.000Z","updated":"2021-09-06T11:55:53.208Z","comments":true,"path":"2021/09/04/Linux常用命令大全/","link":"","permalink":"https://lujaywang.github.io/2021/09/04/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"❝ Linux其实是前后端都必会的技能，前端目前很多童鞋都再走大前端路线，后端就更不用说了，小编通过学习B站上的狂神老师的Linux最通俗易懂的教程学习了相关的命令并对其进行整理，可以说这些都是必须掌握的，当然这些也是不够的，后面小编还会在之后的工作生活中继续整理更新，大家可以关注我的动态，盘起来，这波可以收藏起来了。 ❞ 一、目录相关命令1$ ls [选项]... [文件]... #查看当前目录 常用选项： -a： all，查看所有文件，包括隐藏文件 -l：列出所有的文件包括隐藏文件，ls -l可以简写成ll 1$ cd [选项] [目录路径] #跳转到某个目录 目录路径分位相对路径和绝对路径 相对路径：以/开头。例如：/usr/local 绝对路径：以./或者../开头，./代表当前目录，../代表当前目录所在的目录。例如：./usr,../usr 1234567$ pwd #查看当前文件所在目录$ mkdir test #创建一个目录$ mkdir test1/test2/test3 #test1，test2目录必须存在，否则会报错$ mkdir -p test1/test2/test3 #可以递归创建目录，test1，test2目录可以不存在 $ rmdir test #删除test目录$ rmdir test1/test2 #报错，不能删除不为空的目录$ rmdir -p test1/test2 #可以递归删除目录，⚠️test1下必须只有test2目录不能有其他文件或者目录 1$ cp [选项] 文件1 文件2 #拷贝文件1到文件2 常用选项： -r：recursive，递归复制 -f：force，强制复制，遇到相同文件不会提示直接进行覆盖 -i：互动，复制时会提示是否复制 1rm [选项] 文件或者目录 #删除文件或者目录 常用选项： -r：recursive，递归删除 -f：force，强制删除，遇到相同文件不会提示直接进行删除 -i：互动，删除时提示是否删除 警告⚠️：不要尝试使用rm -rf /命令，会删除所有的文件及目录，即我么常说的删库跑路。 二、文件属性查看及修改 通过ll和ls -l查看当前目录的文件属性 每行第一个字母 [d]代表目录，directory； [-]代表文件； [l]代表链接，link。 另外九个字符分别为三中不同用户组的权限，每三个为一组，分别代表可读可写可执行，三中用户组分别为root用户组，普通用户和游客用户组，其他用户组 123$ chmod [-R] 权限 文件或者目录 #修改文件或者目录的权限$ chown [-R] lujaywang 文件或者目录 #修改文件目录的属主及所有者owner，上图第三个字段$ chgrp [-R] root 文件或者目录 #修改文件的属组及group，上图第四个字段 chmod的权限由三个0，1，2，3，5，7之间数字组成，例如：777，分别代表三个不同的用户组的三个权限，每个数字转换成三位的二进制，例如：1代表001，3代表011，7代表111。三个数字分别代表rwx及可读可写可执行，0代表没有权限即”-“，1代表有权限。 321：-wx-w–x 777：rwxrwxrwx 537：r-x-wxrwx 三、文件的查看1234567$ cat [-n] 文件 #查看文件全部内容，加上-n会显示行号$ tac 文件 #从后往前显示文件全部内容$ nl 文件 #相当于cat -n 文件，显示全部内容加上行号$ more 文件 #显示部分内容，enter键显示更多行，空格键分页，会显示当前内容占全部的比例$ less 文件 #显示部分内容，空格键分页，↑↓键上下查看内容，但是不会显示当前内容占全部的比例$ head [-n number] 文件 #显示头上内容，有-n显示头上number行，没有默认显示10行数据$ tail [-n number] 文件 #显示尾上内容，有-n显示尾上number行，没有默认显示10行数据 创建文件的方法 12$ touch 文件名 #创建文件$ vi / vim 文件名 #通过vi或者和vim方式创建文件 四、硬链接和软链接硬链接：指向文件，文件删除了，硬链接还是可以打开，放在重要文件上，防止误删； 软连接：指向文件，文件删除，软连接也失效了，相当于windows上的快捷方式。 123$ touch f1 #创建f1文件$ ln f1 f2 #创建硬链接f2，命令：ln 文件 链接名$ ln -s f1 f3 #创建软链接f3，加上-s代表创建软连接 三个文件不管哪个文件内容发生改变，另外两个文件内容也会发生改变。 f1删除之后，f3也会失效不能读取，f2还可以读取。","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://lujaywang.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Linux","slug":"Linux","permalink":"https://lujaywang.github.io/tags/Linux/"}]}],"categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"spring","slug":"后端开发/spring","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/spring/"},{"name":"数据库","slug":"后端开发/数据库","permalink":"https://lujaywang.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://lujaywang.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"spring","slug":"spring","permalink":"https://lujaywang.github.io/tags/spring/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lujaywang.github.io/tags/MySQL/"},{"name":"redis","slug":"redis","permalink":"https://lujaywang.github.io/tags/redis/"},{"name":"noSql","slug":"noSql","permalink":"https://lujaywang.github.io/tags/noSql/"},{"name":"Linux","slug":"Linux","permalink":"https://lujaywang.github.io/tags/Linux/"}]}