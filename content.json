{"meta":{"title":"LujayWang's Blog","subtitle":"","description":"","author":"Lujay Wang","url":"https://LujayWang.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-04-20T16:46:45.190Z","updated":"2021-09-02T10:37:10.487Z","comments":false,"path":"/404.html","permalink":"https://lujaywang.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-04-20T16:46:21.328Z","updated":"2023-02-28T14:12:50.354Z","comments":false,"path":"about/index.html","permalink":"https://lujaywang.github.io/about/index.html","excerpt":"","text":"基本信息中文名：汪奇伟英文名：Lujay性 别：男年 龄：25城 市：杭州学 校：东华理工大学 专业技能 1.熟练掌握Java编程语言； 2.熟练掌握数据结构且对算法有一定的研究； 3.熟练掌握Spring、SpringMVC、SpringBoot、MyBatis等主流框架开发； 4.熟练掌握Redis、RabbitMQ消息队列等中间件； 5.熟练掌握MySQL关系型数据库语言及其索引优化； 6.熟练掌握 Linux 常用命令； 7.熟练掌握JUC并发编程; 8.了解 Spring Cloud及Spring Cloud Alibaba技术栈且有实际开发经验 ; 9.了解 Vue、React、JQuery等前端框架及其UI框架且有实际开发经验。 自我评价 乐观向上，平易近人，喜欢主动接触新知识，新事物。热爱coding，对软件开发技术充满兴趣。平常也爱看电影，打羽毛球。"},{"title":"书单","date":"2023-04-20T16:46:31.256Z","updated":"2021-09-02T10:37:10.546Z","comments":false,"path":"books/index.html","permalink":"https://lujaywang.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-04-20T16:46:33.680Z","updated":"2021-09-02T10:37:10.578Z","comments":false,"path":"categories/index.html","permalink":"https://lujaywang.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-04-20T16:46:55.116Z","updated":"2021-09-02T10:37:10.605Z","comments":true,"path":"links/index.html","permalink":"https://lujaywang.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-09-02T10:37:10.633Z","updated":"2021-09-02T10:37:10.633Z","comments":false,"path":"repository/index.html","permalink":"https://lujaywang.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-04-20T16:46:42.747Z","updated":"2021-09-02T10:37:10.661Z","comments":false,"path":"tags/index.html","permalink":"https://lujaywang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式（8）装饰者模式","slug":"设计模式（8）装饰者模式","date":"2023-04-29T10:25:44.000Z","updated":"2023-04-29T12:35:25.512Z","comments":true,"path":"2023/04/29/设计模式（8）装饰者模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%888%EF%BC%89%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是装饰者模式装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 UML类图 案例及代码实现案例 茶饮下单时开始时是一杯纯粹的奶茶或者红茶，当我们加上珍珠或者红豆等各种调料之后，奶茶就被成了珍珠奶茶或者红豆奶茶等等，价格也会随着加料增加而增加，这就是一个奶茶在不断被装饰的过程。 代码实现Drink.java 12345public interface Drink &#123; void print(); double cost();&#125; MilkTea.java 123456789101112131415public class MilkTea implements Drink &#123; private String name = &quot;奶茶&quot;; private Double price = 15.00; @Override public double cost() &#123; return price; &#125; @Override public void print() &#123; System.out.println(&quot;购买一杯&quot; + name + &quot;花费&quot; + price + &quot;元&quot; + &quot;，一共花费&quot; + cost() + &quot;元&quot;); &#125;&#125; RedTea.java 123456789101112131415public class RedTea implements Drink &#123; private String name = &quot;红茶&quot;; private Double price = 14.00; @Override public double cost() &#123; return price; &#125; @Override public void print() &#123; System.out.println(&quot;购买一杯&quot; + name + &quot;花费&quot; + price + &quot;元&quot; + &quot;，一共花费&quot; + cost() + &quot;元&quot;); &#125;&#125; DrinkDecorator.java 12345678910111213141516171819202122public abstract class DrinkDecorator implements Drink&#123; private Drink drink; protected String name; protected Double price; public DrinkDecorator(Drink drink) &#123; this.drink = drink; &#125; @Override public void print() &#123; drink.print(); System.out.println(&quot;加料一份&quot; + name + &quot;花费&quot; + price + &quot;元&quot; + &quot;，一共花费&quot; + cost() + &quot;元&quot;); &#125; @Override public double cost() &#123; return drink.cost() + price; &#125;&#125; PearlDecorator.java 1234567public class PearlDecorator extends DrinkDecorator &#123; public PearlDecorator(Drink drink) &#123; super(drink); this.name = &quot;珍珠&quot;; this.price = 2.00; &#125;&#125; RedBean.java 1234567public class RedBeanDecorator extends DrinkDecorator &#123; public RedBeanDecorator(Drink drink) &#123; super(drink); this.name = &quot;红豆&quot;; this.price = 2.00; &#125;&#125; Client.java 12345678public class Client &#123; public static void main(String[] args) &#123; Drink milkTea = new MilkTea(); Drink pearlMilkTea = new PearlDecorator(milkTea); Drink redBeanPearlMilkTea = new RedBeanDecorator(pearlMilkTea); redBeanPearlMilkTea.print(); &#125;&#125; 运行程序，输出结果： 123购买一杯奶茶花费15.0元，一共花费15.0元加料一份珍珠花费2.0元，一共花费17.0元加料一份红豆花费2.0元，一共花费19.0元 应用场景 Java中I/O流就是装饰模式最典型的应用，字节字符输入输出流。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（7）适配器模式","slug":"设计模式（7）适配器模式","date":"2023-04-27T10:25:15.000Z","updated":"2023-04-27T15:52:55.583Z","comments":true,"path":"2023/04/27/设计模式（7）适配器模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%887%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是适配器模式适配器模式将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 共有三类适配器模式： 对象适配器模式 – 在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。当客户在接口中定义了他期望的行为时，我们就可以应用适配器模式，提供一个实现该接口的类，并且扩展已有的类，通过创建子类来实现适配。 类适配器模式 – 这种适配器模式下，适配器继承自已实现的类（一般多重继承）。对象适配器通过组合除了满足“用户期待接口”还降低了代码间的不良耦合。在工作中推荐使用“对象适配”。 接口适配器模式（缺省适配器模式） – 接口适配器模式（缺省适配器模式）是一种特殊的适配器模式，但这个适配器是由一个抽象类实现的，并且在抽象类中要实现目标接口中所规定的所有方法，但很多方法的实现都是“平庸”的实现，也就是说，这些方法都是空方法。而具体的子类都要继承此抽象类。 UML类图 案例及代码实现案例 如上图是多个不同的苹果电脑充电头，不同国家的插头有不同的标准，苹果公司为了适配所有国家的插头，就需要生产不同的适配器插头，这也是适配器模式的一个经典案例。下面我们来用三类适配器来做具体的实现。 代码实现对象适配器模式Adaptee.java(被适配器类) 12345public class Adaptee &#123; public void output() &#123; System.out.println(&quot;这是美国标准插头&quot;); &#125;&#125; Target.java(目标类) 123public interface Target &#123; void output();&#125; Adapter.java(适配器) 12345678910111213public class Adapter implements Target &#123; private Adaptee adaptee; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void output() &#123; adaptee.output(); System.out.println(&quot;被适配成中国标准充电头&quot;); &#125;&#125; Client.java 123456789public class Client &#123; public static void main(String[] args) &#123; Adaptee adaptee = new Adaptee(); adaptee.output(); System.out.println(&quot;-------------&quot;); Adapter adapter = new Adapter(adaptee); adapter.output(); &#125;&#125; 执行程序，运行结果： 1234这是美国标准插头-------------这是美国标准插头被适配成中国标准充电头 类适配器模式Adaptee.java，Target.java同上 Adapter.java(适配器) 1234567public class Adapter extends Adaptee implements Target &#123; @Override public void output() &#123; super.output(); System.out.println(&quot;被适配成中国标准充电头&quot;); &#125;&#125; Client.java 123456789public class Client &#123; public static void main(String[] args) &#123; Adaptee adaptee = new Adaptee(); adaptee.output(); System.out.println(&quot;-------------&quot;); Adapter adapter = new Adapter(); adapter.output(); &#125;&#125; 执行程序，输出结果： 1234这是美国标准插头-------------这是美国标准插头被适配成中国标准充电头 接口适配器模式（缺省适配器模式）Adaptee.java，Target.java同上 Adapter.java 123456public abstract class Adapter implements Target&#123; @Override public void output() &#123; &#125;&#125; Client.java 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Adaptee adaptee = new Adaptee(); adaptee.output(); System.out.println(&quot;-------------&quot;); Adapter targetAdapter = new Adapter() &#123; @Override public void output() &#123; adaptee.output(); System.out.println(&quot;被适配成中国标准充电头&quot;); &#125; &#125;; targetAdapter.output(); &#125;&#125; 执行程序，输出结果： 1234这是美国标准插头-------------这是美国标准插头被适配成中国标准充电头 应用场景 SpringMVC源码中HandlerMappingAdapter。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（6）代理模式","slug":"设计模式（6）代理模式","date":"2023-04-26T14:14:51.000Z","updated":"2023-04-26T14:14:19.630Z","comments":true,"path":"2023/04/26/设计模式（6）代理模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%886%EF%BC%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是代理模式代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 UML类图 案例及代码实现案例​ 娱乐圈明星都会有他们的经纪人，经纪人会代理明星唱歌，演戏，参加活动等各种事项的工作，但是这些事项的具体执行者还是由明星执行，经纪人会在演出开始之前通知明星，并在演出结束后做收尾工作。 代码实现静态代理（局限性，每个接口都要有一个代理对象）Singer.java 123public interface Singer &#123; void sing();&#125; SingerImpl.java 123456public class SingerImpl implements Singer &#123; @Override public void sing() &#123; System.out.println(&quot;歌手正在唱歌&quot;); &#125;&#125; SingerProxy.java 1234567891011121314public class SingerProxy implements Singer&#123; private Singer singer; public SingerProxy(Singer singer) &#123; this.singer = singer; &#125; @Override public void sing() &#123; System.out.println(&quot;歌手准备唱歌&quot;); singer.sing(); System.out.println(&quot;歌手结束唱歌&quot;); &#125;&#125; Client.java 1234567public class Client &#123; public static void main(String[] args) &#123; Singer singer = new SingerImpl(); SingerProxy singerProxy = new SingerProxy(singer); singerProxy.sing(); &#125;&#125; 执行程序，输出结果： 123歌手准备唱歌歌手正在唱歌歌手结束唱歌 jdk动态代理（必须有接口）Singer.java，SingerImpl.class同上 JdkProxy.java 12345678910111213141516171819public class JdkProxy&lt;T&gt; implements InvocationHandler &#123; private T obj; private JdkProxy(T obj) &#123; this.obj = obj; &#125; public static &lt;T&gt; T getInstance(T obj) &#123; return (T) Proxy.newProxyInstance(JdkProxy.class.getClassLoader(), obj.getClass().getInterfaces(), new JdkProxy&lt;T&gt;(obj)); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;jdk动态代理开始&quot;); Object res = method.invoke(obj, args); System.out.println(&quot;jdk动态代理结束&quot;); return res; &#125;&#125; Client.java 1234567public class Client &#123; public static void main(String[] args) &#123; Singer singer = new SingerImpl(); Singer singerProxy = JdkProxy.getInstance(singer); singerProxy.sing(); &#125;&#125; 执行程序，输出结果： 123jdk动态代理开始歌手正在唱歌jdk动态代理结束 cglib动态代理（不用有接口，底层通过字节码增强器，创建被代理类子类（继承））pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.12&lt;/version&gt;&lt;/dependency&gt; Singer.java 12345public class Singer &#123; public void sing() &#123; System.out.println(&quot;歌手正在唱歌&quot;); &#125;&#125; CglibProxy.java 12345678910111213141516171819202122232425public class CglibProxy&lt;T&gt; implements MethodInterceptor &#123; private T target; private CglibProxy(T target) &#123; this.target = target; &#125; public static &lt;T&gt; T getInstance(T target) &#123; // 字节码增强器 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); // 回调函数为MethodInterceptor enhancer.setCallback(new CglibProxy&lt;&gt;(target)); T obj = (T) enhancer.create(); return obj; &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;cglib动态代理开始&quot;); Object res = method.invoke(target, args); System.out.println(&quot;cglib动态代理结束&quot;); return res; &#125;&#125; Client.java 1234567public class Client &#123; public static void main(String[] args) &#123; Singer singer = new Singer(); Singer singerProxy = CglibProxy.getInstance(singer); singerProxy.sing(); &#125;&#125; 执行程序，输出结果： 123cglib动态代理开始歌手正在唱歌cglib动态代理结束 应用场景各大主流框架源码 Spring源码混合使用了jdk动态代理和cglib动态代理。 Mybatis源码使用了jdk动态代理。 Dubbo、OpenFeign源码使用了jdk动态代理。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（5）建造者模式","slug":"设计模式（5）建造者模式","date":"2023-04-20T10:24:31.000Z","updated":"2023-04-26T13:59:42.432Z","comments":true,"path":"2023/04/20/设计模式（5）建造者模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%885%EF%BC%89%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是建造者模式建造者模式是设计模式的一种，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 UML类图 案例及代码实现案例​ 据传说，女娲是中国神话中的创世女神，也是中国人类起源的神话人物之一。根据传说，她用五彩石修补天空，用黄土塑造了人类，并赋予了人类智慧和生命力，并分为男人和女人，让他们能够自由繁衍，生生不息。女娲造人的过程非常神奇，据说她用泥巴塑造出一个个活生生的人形，然后将它们放到火中烤，使得它们更加坚固和有生命力。 代码实现Person.java 123456789public interface Person &#123; void setColor(String color); void setSex(String sex); String getColor(); String getSex();&#125; YellowPerson.java 12345678910111213141516171819202122232425public class YellowPerson implements Person&#123; private String color; private String sex; @Override public String getColor() &#123; return color; &#125; @Override public void setColor(String color) &#123; this.color = color; &#125; @Override public String getSex() &#123; return sex; &#125; @Override public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; Builder.java 123456789101112131415public abstract class Builder &#123; public abstract void setColor(String color); public abstract void setSex(String sex); protected Person person; public Builder() &#123; this.person = new YellowPerson(); &#125; public Person getPerson() &#123; return person; &#125;&#125; YellowPersonBuilder.java 123456789101112public class YellowPersonBuilder extends Builder &#123; @Override public void setColor(String color) &#123; person.setColor(color); &#125; @Override public void setSex(String sex) &#123; person.setSex(sex); &#125;&#125; Director.java 123456789101112131415161718192021public class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public Person createPerson(String color, String sex) &#123; builder.setSex(sex); builder.setColor(color); return builder.getPerson(); &#125; public static void main(String[] args) &#123; YellowPersonBuilder yellowPersonBuilder = new YellowPersonBuilder(); Director director = new Director(yellowPersonBuilder); YellowPerson person = (YellowPerson) director.createPerson(&quot;yellow&quot;, &quot;man&quot;); System.out.println(person.getSex()); System.out.println(person.getColor()); &#125;&#125; 执行程序，输出结果： 12yellowman 应用场景各种以Builder结尾的Builder类，例如StringBuilder。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（4）原型模式","slug":"设计模式（4）原型模式","date":"2023-04-19T10:24:11.000Z","updated":"2023-04-25T14:33:48.944Z","comments":true,"path":"2023/04/19/设计模式（4）原型模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%884%EF%BC%89%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是原型模式原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 UML类图 案例及代码实现案例​ 克隆羊，是指用已经分化的成熟的体细胞（乳腺细胞）克隆出的羊。多利是世界上第一只成功克隆的羊。这项研究不仅对胚胎学、发育遗传学、医学有重大意义，而且也有巨大的经济潜力。克隆技术可以用于器官移植，造福人类；也可以通过这项技术改良物种，给畜牧业带来好处。克隆技术若与转基因技术相结合，可大批量“复制”含有可产生药物原料的转基因动物，从而使克隆技术更好地为人类服务。世界第一批无性繁殖的转基因羊也在英国诞生，下面我们通过原型模式实现克隆羊的相关功能。 代码实现浅克隆（除了八大基本类型克隆的都是引用而不是值）Sheep.class 1234567891011121314151617181920212223242526272829303132333435363738public abstract class Sheep implements Cloneable &#123; private String type; private String color; public Sheep(String type, String color) &#123; this.type = type; this.color = color; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override protected Object clone() &#123; Object obj = null; try &#123; obj = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; System.err.println(&quot;AbstractSheep is not Cloneable&quot;); &#125; return obj; &#125;&#125; HappSheep.class 12345public class HappySheep extends Sheep &#123; public HappySheep(String type, String color) &#123; super(type, color); &#125;&#125; LazySheep.class 12345public class LazySheep extends Sheep&#123; public LazySheep(String type, String color) &#123; super(type, color); &#125;&#125; Client.class 123456789101112public class Client &#123; public static void main(String[] args) &#123; HappySheep happySheep = new HappySheep(&quot;happy&quot;, &quot;blue&quot;); HappySheep happySheepClone = (HappySheep) happySheep.clone(); System.out.println(happySheepClone.getType()); System.out.println(happySheepClone.getColor()); LazySheep lazySheep = new LazySheep(&quot;lazy&quot;, &quot;yellow&quot;); LazySheep lazySheepClone = (LazySheep) lazySheep.clone(); System.out.println(lazySheepClone.getType()); System.out.println(lazySheepClone.getColor()); &#125;&#125; 执行程序，输出结果： 1234happybluelazyyellow 深克隆（使用jdk序列化的方式）Sheep.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public abstract class Sheep implements Cloneable, Serializable &#123; private String type; private String color; private Sheep friend; public Sheep(String type, String color) &#123; this.type = type; this.color = color; &#125; public Sheep getFriend() &#123; return friend; &#125; public void setFriend(Sheep friend) &#123; this.friend = friend; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override protected Object clone() &#123; Object object = null; ByteArrayOutputStream byteArrayOutputStream = null; ObjectOutputStream objectOutputStream = null; ByteArrayInputStream byteArrayInputStream = null; ObjectInputStream objectInputStream = null; try &#123; byteArrayOutputStream = new ByteArrayOutputStream(); objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(this); byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); objectInputStream = new ObjectInputStream(byteArrayInputStream); object = objectInputStream.readObject(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (objectInputStream != null) &#123; try &#123; objectInputStream.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; if (objectOutputStream != null) &#123; try &#123; objectOutputStream.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; return object; &#125;&#125; HappSheep.java同上 LazySheep.java同上 Client.java 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; HappySheep happySheep = new HappySheep(&quot;happy&quot;, &quot;blue&quot;); HappySheep happySheepClone = (HappySheep) happySheep.clone(); System.out.println(happySheepClone.getType()); System.out.println(happySheepClone.getColor()); LazySheep lazySheep = new LazySheep(&quot;lazy&quot;, &quot;yellow&quot;); lazySheep.setFriend(happySheep); LazySheep lazySheepClone = (LazySheep) lazySheep.clone(); happySheep.setColor(&quot;white&quot;); System.out.println(lazySheepClone.getType()); System.out.println(lazySheepClone.getColor()); // 引用类型北深拷贝，输出blue不是white System.out.println(lazySheepClone.getFriend().getColor()); &#125;&#125; 执行程序，输出结果： 12345happybluelazyyellowblue 应用场景spring创建bean时，scope域为prototype时，每次注入bean时都会返回一个新的bean实例。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（3）抽象工厂模式","slug":"设计模式（3）抽象工厂模式","date":"2023-04-18T10:23:50.000Z","updated":"2023-04-25T14:34:06.535Z","comments":true,"path":"2023/04/18/设计模式（3）抽象工厂模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%883%EF%BC%89%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是抽象工厂模式​ 抽象工厂模式（Abstract Factory Pattern）隶属于设计模式中的创建型模式，用于产品族的构建。抽象工厂是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂是指当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体情况下，创建多个产品族中的产品对象。 ​ 工厂模式中的每一个形态都是针对一定问题的解决方案，工厂方法针对的是多个产品系列结构；而抽象工厂模式针对的是多个产品族结构，一个产品族内有多个产品系列，可以说抽象工厂模式是对工厂方法模式的扩展。 案例及代码实现案例 代码实现Shape.java 123public interface Shape &#123; void draw();&#125; Rectangle.java 1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125; Square.java 1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125; Circle.java 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; Color.java 123public interface Color &#123; void fill();&#125; Red.java 1234567public class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Red::fill() method.&quot;); &#125;&#125; Green.java 1234567public class Green implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Green::fill() method.&quot;); &#125;&#125; Blue.java 1234567public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Blue::fill() method.&quot;); &#125;&#125; AbstractFactory.java 1234public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape);&#125; ShapeFactory.java 12345678910111213141516171819202122public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125; ColorFactory.java 12345678910111213141516171819202122public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override public Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123; return new Blue(); &#125; return null; &#125;&#125; FactoryProducer.java 12345678910public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; AbstractFactoryPatternDemo.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;GREEN&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 执行程序，输出结果： 123456Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（2）工厂模式","slug":"设计模式（2）工厂模式","date":"2023-04-16T14:46:00.000Z","updated":"2023-04-25T14:34:14.882Z","comments":true,"path":"2023/04/16/设计模式（2）工厂模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 UML类图 案例及实现案例我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。 FactoryPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 代码实现Shape.java 123public interface Shape &#123; void draw(); &#125; Rectangle.java 123456public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125; &#125; Square.java 123456public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125; &#125; Circle.java 123456public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125; &#125; ShapeFactory.java 1234567891011121314151617public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125;&#125; FactoryPatternDemo.java 123456789101112131415161718192021222324public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 执行程序，输出结果： 123Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method. 应用场景 简单工厂BeanFactory。 工厂方法FactoryBean。 简单工厂和工厂方法LoggerFactory。 在JDK源码中 ，java.util.Calendar使用了工厂模式的简单工厂模式。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式（1）单例模式","slug":"设计模式（1）单例模式","date":"2023-04-15T14:12:30.000Z","updated":"2023-04-23T11:56:32.739Z","comments":true,"path":"2023/04/15/设计模式（1）单例模式/","link":"","permalink":"https://lujaywang.github.io/2023/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是单例模式单例模式提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 UML类图 单例模式的几种实现1）饿汉式1234567891011121314151617public class HungrySingleton &#123; /** * 私有化构造器 */ private HungrySingleton() &#123; &#125; /** * 还没有调用就直接创建，没有线程安全问题，但是浪费内存资源 */ private final static HungrySingleton hungerSingleton1 = new HungrySingleton(); public final static HungrySingleton getInstance() &#123; return hungerSingleton1; &#125;&#125; 2）懒汉式，线程不安全12345678910111213141516171819public class LazySingleton1 &#123; private LazySingleton1() &#123; &#125; private static LazySingleton1 instance; /** * 存在线程安全问题 * * @return */ public static LazySingleton1 getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton1(); &#125; return instance; &#125;&#125; 3）懒汉式，在方法上使用synchronized关键字1234567891011121314public class LazySingleton2 &#123; private LazySingleton2() &#123; &#125; private static LazySingleton2 instance; public synchronized static LazySingleton2 getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton2(); &#125; return instance; &#125;&#125; 4）懒汉式，使用双重校验锁（DCL，ouble-checked locking）1234567891011121314151617181920212223public class LazySingleton3 &#123; private LazySingleton3() &#123; &#125; /** * volatile保证了内存可见性，防止指令重排，不能保证原子性 */ private static volatile LazySingleton3 instance; public static final LazySingleton3 getInstance() &#123; // 减少多线程情况下线程的等待时间 if (instance == null) &#123; synchronized (LazySingleton3.class) &#123; // 如果之前的线程已经创建成功就不创建新的实例，返回之前的实例 if (instance == null) &#123; instance = new LazySingleton3(); &#125; &#125; &#125; return instance; &#125;&#125; 5）懒汉式，使用内部类1234567891011121314151617public class LazySingleton4 &#123; private LazySingleton4() &#123; &#125; /** * 利用内部类延时加载机制实现单例模式，也是懒汉式单例模式的一种实现方式 * 内部类只有在被使用的时候才会被加载 */ private static final class InnerClass &#123; private static final LazySingleton4 instance = new LazySingleton4(); &#125; public static final LazySingleton4 getInstance() &#123; return InnerClass.instance; &#125;&#125; 6）使用枚举类12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 应用场景spring创建bean时，scope域为singleton时，只会生成一个共享的实例，所有对这个bean的请求都会返回唯一的实例。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式概述","slug":"设计模式概述","date":"2023-04-03T15:25:00.000Z","updated":"2023-04-23T11:58:51.385Z","comments":true,"path":"2023/04/03/设计模式概述/","link":"","permalink":"https://lujaywang.github.io/2023/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一、什么是设计模式​ 设计模式(英语 design pattern)是对面向对象设计中反复出现的问题的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的。这个术语的含义还存有争议。算法不是设计模式，因为算法致力于解决问题而非设计问题。设计模式通常描述了一组相互紧密作用的类与对象。设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。 二、七大原则​ 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)， 1）单一职责原则一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。即每个类只负责自己的事情，而不是变成万能 2）接口隔离原则一个类对另一个类的依赖应该建立在最小的接口上。即各个类建立自己的专用接口，而不是建立万能接口 3）依赖倒转（倒置）原则高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。即面向接口编程，而不是面向实现类 4）里氏替换原则 继承必须确保超类所拥有的性质在子类中仍然成立。即继承父类而不去改变父类的功能 5）开闭原则软件实体应当对扩展开放，对修改关闭（对提供方扩展开放，对调用端修改关闭）。即扩展新类而不是修改旧类（合成复用原则、里氏替换原则相辅相成，都是开闭原则的具体实现规范） 6）迪米特法则最少知识原则，只与你的直接朋友交谈，不跟“陌生人”说话。即无需直接交互的两个类，如果需要交互，使用中间者 直接朋友: 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部 7）合成复用原则软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。即优先组合，其次继承 三、设计模式分类设计模式主要有23中，根据设计模式的功能划分可以分成三大类： 创建型模式：原型模式、工厂模式、抽象工厂模式、单例模式、建造者模式。 结构型模式：代理模式、适配器模式、装饰者模式、组合模式、外观模式、桥接模式、享元模式。 行为型模式：迭代器模式、责任链模式、备忘录模式、命令模式、中介者模式、策略模式、模板模式、观察者模式、状态模式、访问者模式、解释器模式。 记忆口诀： 创建型模式：原（原型模式）来建（建造者模式）设工（工厂模式）人单（单例模式）独抽（抽象工厂模式）奖。 结构型模式：带（代理模式）着适（适配器模式）当的装（装饰者模式）备组合（组合模式）让外（外观模式）国侨（桥接模式）胞享（享元模式）受游戏。 行为型模式：多次（迭代器模式）命令（命令模式）和责（责任链模式）备（备忘录模式）中（中介者模式），车（策略模式）模（模板模式）见（观察者模式）状（状态模式）慌（访问者模式）忙解（解释器模式）开衣服。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"bean生命周期","slug":"bean生命周期","date":"2023-02-28T15:11:00.000Z","updated":"2023-03-04T10:45:23.011Z","comments":true,"path":"2023/02/28/bean生命周期/","link":"","permalink":"https://lujaywang.github.io/2023/02/28/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"一、bean的生命周期bean的生命周期即bean从创建到销毁的全过程，但总体可以分为bean定义、实例化、属性填充、初始化（afterPropertiesSet）、生存期、销毁六个阶段。 二、图解bean的生命周期 bean定义：通过ComponentScan扫描类并生成BeanDefinition； 实例化bean：根据BeanDefinition生成对应的bean； 属性填充：依赖注入填充bean的属性值； 初始化：实现aware接口，设置对应的值 –&gt;调用InitializingBean的afterPropertiesSet方法 –&gt; 调用&lt; bean &gt;的 init-method方法； 生存期：执行BeanPostProccessor的postProcessAfterinitialization()方法 –&gt; 将单例bean存入单例池中 –&gt; 将bean给调用方使用； 销毁：调用DisposableBean的destory()方法（和InitializingBean对应）–&gt; 调用&lt; bean &gt;的destory-method方法。 注意：AOP(object orient program)的底层实现原理是通过实现BeanPostProcessor的postProcessAfterinitialization()方法，通过cglib的字节码增强器（Enhancer）生成bean的代理对象，经过AOP生成的bean是bean的代理对象和根据BeanDefinition实例化的bean是两个不同的对象，也就会导致事务传播机制中会存在同一个类中事务传播失效的问题（后续专门补充章节介绍）。 三、代码测试测试代码： OrderService.java 123@Componentpublic class OrderService &#123;&#125; UserService.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class UserService implements InitializingBean, DisposableBean, BeanNameAware &#123; public UserService() &#123; System.out.println(&quot;实例化bean&quot;); &#125; private String beanName; @Autowired private OrderService orderService; public void setBeanName(String s) &#123; this.beanName = beanName; System.out.println(&quot;调用Aware接口，设置容器属性&quot;); &#125; @PostConstruct public void postConstruct() &#123; System.out.println(&quot;调用@PostConstruct注解标注的方法&quot;); &#125; private void initMethod() &#123; System.out.println(&quot;调用&lt;bean&gt;配置的initMethod方法&quot;); &#125; public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;调用InitializingBean的afterPropertiesSet方法&quot;); &#125; @PreDestroy public void preDestroy() &#123; System.out.println(&quot;调用@PreDestroy注解标注的方法&quot;); &#125; public void destroy() throws Exception &#123; System.out.println(&quot;调用DisposableBean的destroy方法&quot;); &#125; private void destroyMethod() &#123; System.out.println(&quot;调用&lt;bean&gt;配置的destroyMethod方法&quot;); &#125;&#125; MyBeanPostProcessor.java 123456789101112@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;调用BeanPostProcessor的前置处理器&quot;); return bean; &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;调用BeanPostProcessor的后置处理器&quot;); return bean; &#125;&#125; SpringApplicationContext.java 123456789101112131415@Configuration@ComponentScan(&quot;com.lujay&quot;)public class SpringApplicationContext &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringApplicationContext.class); UserService userService = context.getBean(UserService.class); System.out.println(userService); context.close(); &#125; @Bean(initMethod = &quot;initMethod&quot;, destroyMethod = &quot;destroyMethod&quot;) public UserService getUserService() &#123; return new UserService(); &#125;&#125; 运行结果： 1234567891011实例化bean调用Aware接口，设置容器属性调用BeanPostProcessor的前置处理器调用@PostConstruct注解标注的方法调用InitializingBean的afterPropertiesSet方法调用&lt;bean&gt;配置的initMethod方法调用BeanPostProcessor的后置处理器com.lujay.UserService@11dc3715调用@PreDestroy注解标注的方法调用DisposableBean的destroy方法调用&lt;bean&gt;配置的destroyMethod方法","categories":[{"name":"spring","slug":"spring","permalink":"https://lujaywang.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://lujaywang.github.io/tags/spring/"},{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"}]},{"title":"MySQL的事务隔离级别及脏读、幻读、不可重复读","slug":"MySQL的事务隔离级别及脏读-幻读-不可重复读","date":"2021-09-06T15:13:09.000Z","updated":"2023-03-04T10:45:00.506Z","comments":true,"path":"2021/09/06/MySQL的事务隔离级别及脏读-幻读-不可重复读/","link":"","permalink":"https://lujaywang.github.io/2021/09/06/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%8A%E8%84%8F%E8%AF%BB-%E5%B9%BB%E8%AF%BB-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/","excerpt":"","text":"一 数据库事务的隔离级别数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。 1. Read UnCommitted(读未提交)最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果。 2. Read Committed(读提交)大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。 3. Repeatable Read(重复读)mysql的默认级别。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。 4. Serializable(序列化)最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。 二 不同事务级别带来的并发问题1 脏读脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。这跟不可重复读类似，但是第二个事务不需要执行提交。 2 不可重复读在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题。 在上面这个例子中，事务2提交成功，它所做的修改已经可见。然而，事务1已经读取了一个其它的值。在序列化和可重复读的隔离级别中，数据库管理系统会返回旧值，即在被事务2修改之前的值。在提交读和未提交读隔离级别下，可能会返回被更新的值，这就是“不可重复读”。 有两个策略可以防止这个问题的发生： (1) 推迟事务2的执行，直至事务1提交或者回退。这种策略在使用锁时应用。 (2) 而在多版本并行控制中，事务2可以被先提交。而事务1，继续执行在旧版本的数据上。当事务1终于尝试提交时，数据库会检验它的结果是否和事务1、事务2顺序执行时一样。如果是，则事务1提交成功。如果不是，事务1会被回退。 3 幻读 幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。 发生的条件：没有范围锁。 三 例子比较不可重复读和幻读1 不可重复读不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 例子: 在事务1中，Mary 读取了自己的工资为1000,操作并没有完成 12con1 = getConnection(); select salary from employee empId =&quot;Mary&quot;; 在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务. 123con2 = getConnection(); update employee set salary = 2000; con2.commit(); 在事务1中，Mary 再次读取自己的工资时，工资变为了2000 1select salary from employee empId =&quot;Mary&quot;; 在一个事务中前后两次读取的结果并不致，导致了不可重复读。 2 幻读幻读的重点在于新增或者删除 (数据条数变化)。同样的条件, 第1次和第2次读出来的记录数不一样 例子： 目前工资为1000的员工有10人。事务1,读取所有工资为1000的员工。 12con1 = getConnection(); Select * from employee where salary =1000; 共读取10条记录 这时另一个事务向employee表插入了一条员工记录，工资也为1000 123con2 = getConnection(); Insert into employee(empId,salary) values(&quot;Lili&quot;,1000); con2.commit(); 事务1再次读取所有工资为1000的员工 1select * from employee where salary =1000; 共读取到了11条记录，这就像产生了幻读。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lujaywang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lujaywang.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://lujaywang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","permalink":"https://lujaywang.github.io/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"Redis学习笔记","slug":"Redis学习笔记","date":"2021-09-05T06:21:03.000Z","updated":"2023-04-26T14:25:51.288Z","comments":true,"path":"2021/09/05/Redis学习笔记/","link":"","permalink":"https://lujaywang.github.io/2021/09/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"❝ Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。本文Redis相关命令基于Linux CentOs 8系统 ❞ 一、如何将redis在后台启动？ 将redis的配置文件redis.conf的daemonize设置为yes再启动即可；也可以拷贝redis.conf文件，然后在修改拷贝的文件，redis-server 拷贝后文件地址命令指定新的配置文件地址。 二、redis压力测试1$ redis-benchmark -h 127.0.0.1 -p 6379 -c 50 -n 10000 三、Linux远程服务器上的redis怎么在本地通过可视化软件(Medis, Redist Manager Desktop)进行连接访问？ 1）去服务器安全组将对应的端口号放开 2）将端口的防火墙打开，并重启防火墙 ​ firewall-cmd –permanent –add-port=6379/tcp ​ firwall-cmd –reload 或者 systemctl restart firewalld.service 3）还是不行的，查看redis配置文件上的bind 127.0.0.1是否注释掉，protected-mode是否设置为no 四、常用命令1234567891011121314151617181920212223242526272829303132333435[root@LujayWang bin]# redis-cli -p 6379 #进入redis客户端127.0.0.1:6379&gt; ping #判断是否连接成功PONG127.0.0.1:6379&gt; select 1 #选择redis数据库，一共有16个，从0开始OK127.0.0.1:6379[1]&gt; set name &quot;wangqiwei&quot; #redis是以key-value键值对进行存储的，设置key为name的值为&quot;wangqiwei&quot;OK127.0.0.1:6379[1]&gt; get name #获取key值为name的值&quot;wangqiwei&quot;127.0.0.1:6379[1]&gt; keys * #查看所有键1) &quot;name&quot;127.0.0.1:6379[1]&gt; select 0 #第0号数据库为默认数据库OK127.0.0.1:6379&gt; flushdb #清空当前数据库的数据OK127.0.0.1:6379&gt; flushall #清空所有数据库的数据OK 127.0.0.1:6379&gt; keys * #查看所有键(empty list or set)127.0.0.1:6379&gt; set name wangqiweiOK127.0.0.1:6379&gt; type name #查看某个key值的数据类型string127.0.0.1:6379&gt; exists name #查看是否有存在名字为name的key，有返回1，没有返回0(integer) 1127.0.0.1:6379&gt; exists name1(integer) 0127.0.0.1:6379&gt; expire name 10 #设置name的过期时间为10s(integer) 1127.0.0.1:6379&gt; ttl name #查看key还有多久过期，整数表示还剩多少s过期，负数表示已过期(integer) 5127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; keys *(empty list or set) 注意：Redis是单线程的！ 五、Redis数据类型1.String字符串类型1）常用字符串操作123456789101112131415161718192021################################127.0.0.1:6379&gt; flushdb OK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set key1 helloOK127.0.0.1:6379&gt; get key1&quot;hello&quot;127.0.0.1:6379&gt; append key1 ,redis #向key1中追加字符串，返回值追加后的字符串长度(integer) 11127.0.0.1:6379&gt; get key1&quot;hello,redis&quot;127.0.0.1:6379&gt; strlen key1 #获取key1字符串的长度(integer) 11127.0.0.1:6379&gt; append key2 lujaywang #如果append的key不存在，则会创建该key，值为追加的字符(integer) 9127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot;################################## 2）操作数值型数据12345678910111213141516171819202122232425262728##################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set value 0OK127.0.0.1:6379&gt; get value&quot;0&quot;127.0.0.1:6379&gt; type value #redis中的数值还是以字符串形式存储的，但不影响对其进行操作string127.0.0.1:6379&gt; incr value #对value的值加一，类似i++(integer) 1127.0.0.1:6379&gt; incr value(integer) 2127.0.0.1:6379&gt; decr value #对value的值减一，累死(integer) 1127.0.0.1:6379&gt; decr value(integer) 0127.0.0.1:6379&gt; incrby value 10 #对value的值加10，最后一个参数为步长，类似i += 10(integer) 10127.0.0.1:6379&gt; incrby value 10(integer) 20127.0.0.1:6379&gt; decrby value 10 #对value的值减10，最后一个参数为步长，累死i -= 10(integer) 10127.0.0.1:6379&gt; decrby value 10(integer) 0#################################### 3）字符操作扩展123456789101112131415161718####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set str hello,redisOK127.0.0.1:6379&gt; get str&quot;hello,redis&quot;127.0.0.1:6379&gt; getrange str 1 3 #获取字符串索引1到3的字符串，类似于java中substring操作&quot;ell&quot;127.0.0.1:6379&gt; getrange str 0 -1 #获取全部字符串，-1代表最后&quot;hello,redis&quot;127.0.0.1:6379&gt; setrange str 1 haha #将索引为1后面的&#x27;haha&#x27;长度字符串替换为&#x27;haha&#x27;，类似于java中replace操作(integer) 11127.0.0.1:6379&gt; get str&quot;hhaha,redis&quot;#################################### 4）设置获取字符串扩展1234567891011121314151617181920212223242526####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; setex key1 15 hahahaha #set expire合并简写，创建key:value并设置过期时间,如果key已存在则修改值并设置过期时间OK127.0.0.1:6379&gt; get key1&quot;hahahaha&quot;127.0.0.1:6379&gt; ttl key1(integer) 7127.0.0.1:6379&gt; ttl key1(integer) -2127.0.0.1:6379&gt; get key1(nil)127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; setnx key2 xixixi #set if not exit简写，如果不存在就创建key:value,存在就不会进行创建和修改值(integer) 1127.0.0.1:6379&gt; get key2&quot;xixixi&quot;127.0.0.1:6379&gt; setnx key2 hehehe(integer) 0127.0.0.1:6379&gt; get key2&quot;xixixi&quot;#################################### 5）组合操作12345678910111213141516171819202122####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; mset key1 a key2 b key3 c #同时对key1,key2,key3进行赋值OK127.0.0.1:6379&gt; mget key1 key2 key3 #同时获取key1,key2,key3的值1) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot;127.0.0.1:6379&gt; msetnx key1 d key4 d #如果key1,key4都不存在，则设置key1,key4的值；有一个存在，则都不进行设置；具有原子性，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379&gt; mget key1 key41) &quot;a&quot;2) (nil)127.0.0.1:6379&gt; msetnx key4 3 key5 2(integer) 1127.0.0.1:6379&gt; mget key4 key51) &quot;3&quot;2) &quot;2&quot;#################################### 6）对象操作1234567891011####################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set user &quot;&#123;name:&#x27;wangqiwei&#x27;,age:18&#125;&quot; #设置json字符串的方式OK127.0.0.1:6379&gt; set user:name wangqiwei #设置key值的方式分别设置，单个字段或者字段不多的情况下推荐使用OK127.0.0.1:6379&gt; set user:age 18 #设置key值的方式分别设置OK 2.List列表类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081######################################127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; lpush list1 b c d #创建list1列表初始化为b,c,d(integer) 3127.0.0.1:6379&gt; lrange list1 0 -1 #查看数据，（0，-1）表示全部数据1) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;127.0.0.1:6379&gt; lpush list1 a #左边插入一条数据a(integer) 4127.0.0.1:6379&gt; lrange list1 0 -11) &quot;a&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;127.0.0.1:6379&gt; rpush list1 e #右边插入数据e(integer) 5127.0.0.1:6379&gt; lrange list1 0 -11) &quot;a&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;5) &quot;e&quot;127.0.0.1:6379&gt; lpop list1 #左边删除一条数据，最后可以加一个数字代表删除多少条，没有默认一条&quot;a&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;4) &quot;e&quot;127.0.0.1:6379&gt; rpop list1 #右边删除一条数据，最后可以加一个数字代表删除多少条，没有默认一条&quot;e&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;b&quot;127.0.0.1:6379&gt; llen list1 #获取列表长度(integer) 3127.0.0.1:6379&gt; lset list1 1 f #修改索引为1(从0开始)的值为f，列表必须存在且不能越界否则会报错 OK127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;f&quot;3) &quot;b&quot;127.0.0.1:6379&gt; rpoplpush list1 list2 #list右边第一条数据删除并将这条数据从左边推入到list2中&quot;b&quot;127.0.0.1:6379&gt; lrange list2 0 0 1) &quot;b&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;f&quot;127.0.0.1:6379&gt; lrem list1 1 d #删除list1中一条值为d的数据(integer) 1127.0.0.1:6379&gt; lrange list1 0 -11) &quot;f&quot;127.0.0.1:6379&gt; linsert list1 before f a #在list1的第一个值为f的前面插入一条数据啊(integer) 2127.0.0.1:6379&gt; lrange list1 0 -11) &quot;a&quot;2) &quot;f&quot;127.0.0.1:6379&gt; lpush list1 b c d e(integer) 6127.0.0.1:6379&gt; lrange list1 0 -11) &quot;e&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;b&quot;5) &quot;a&quot;6) &quot;f&quot;127.0.0.1:6379&gt; ltrim list1 2 4 #将list1的数据进行裁剪，保留索引为2到4之间的数据OK127.0.0.1:6379&gt; lrange list1 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;127.0.0.1:6379&gt; exists list1 #判断列表是否存在(integer) 1127.0.0.1:6379&gt; lindex list1 1 #获取索引值为1的数据 &quot;f&quot;########################################## 总结： 增加数据：lpush、rpush、linsert、rpoplpush 删除数据：lpop、rpop、ltrim、lrem、rpoplpush 修改数据：lset 查看数据：lrange、lindex 查看长度：llen 判断是否存在：exists 3.Set集合类型1234567891011121314151617181920212223242526272829303132333435363738394041424344##########################################127.0.0.1:6379&gt; sadd myset hello world redis #创建myset并向其中添加元素(integer) 3127.0.0.1:6379&gt; smembers myset #查看set的元素1) &quot;world&quot;2) &quot;redis&quot;3) &quot;hello&quot;127.0.0.1:6379&gt; sismember myset hello #判断某个值是否为set的元素(integer) 1127.0.0.1:6379&gt; scard myset #查看set的长度(integer) 3127.0.0.1:6379&gt; srem myset hello #删除set中的某一个元素(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;world&quot;2) &quot;redis&quot;127.0.0.1:6379&gt; srandmember myset #随机查看set中的一个元素,后面可以加数字，查看随机几个元素&quot;world&quot;127.0.0.1:6379&gt; srandmember myset&quot;redis&quot;127.0.0.1:6379&gt; spop myset #随机删除set中的一个元素&quot;world&quot;127.0.0.1:6379&gt; smove myset myset2 redis #将myset中的一个元素移到myset2中，myset2不存在就自动创建(integer) 1127.0.0.1:6379&gt; smembers myset(empty array)127.0.0.1:6379&gt; smembers myset21) &quot;redis&quot;127.0.0.1:6379&gt; sadd key1 a b c(integer) 3127.0.0.1:6379&gt; sadd key2 c d e(integer) 3127.0.0.1:6379&gt; sdiff key1 key2 #key1中存在，key2中不存在的元素，差集1) &quot;b&quot;2) &quot;a&quot;127.0.0.1:6379&gt; sinter key1 key2 #交集1) &quot;c&quot;127.0.0.1:6379&gt; sunion key1 key2 #并集1) &quot;a&quot;2) &quot;e&quot;3) &quot;c&quot;4) &quot;b&quot;5) &quot;d&quot;######################################### 总结： sadd：创建并新增元素 smembers：查看set里面的元素 sismember：查看某个值是否为set中的元素 srem：删除指定的元素 srandmember：获取随机一个或者几个元素 spop：随机删除一个元素 smove：移动一个set中的元素到另一个set中 sdiff：查看两个set的差集 sinter：查看两个set的交集 sunion：查看两个set的并集 4.Hash哈希类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152############################################127.0.0.1:6379&gt; hset myhash field1 a field2 b #新建hash并初始化(integer) 2127.0.0.1:6379&gt; hget myhash field1 #获取hash中的某一个值&quot;a&quot;127.0.0.1:6379&gt; hmget myhash field1 field2 #获取hash中的几个键值1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379&gt; hmset myhash field1 c fied3 d #批量设置属性值OK127.0.0.1:6379&gt; hgetall myhash #获取所有值1) &quot;field1&quot;2) &quot;c&quot;3) &quot;field2&quot;4) &quot;b&quot;5) &quot;fied3&quot;6) &quot;d&quot;127.0.0.1:6379&gt; hdel myhash field1 #删除hash中的某一个键值(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;b&quot;3) &quot;fied3&quot;4) &quot;d&quot;127.0.0.1:6379&gt; hlen myhash #获取hash的长度(integer) 2127.0.0.1:6379&gt; hexists myhash field2 #判断hash是否存在某一个键(integer) 1127.0.0.1:6379&gt; hkeys myhash #获取hash的所有键1) &quot;field2&quot;2) &quot;fied3&quot;127.0.0.1:6379&gt; hvals myhash #获取hash的所有值1) &quot;b&quot;2) &quot;d&quot;127.0.0.1:6379&gt; hset myhash field4 5 (integer) 1127.0.0.1:6379&gt; hincrby myhash field4 1 #将键值+1(integer) 6127.0.0.1:6379&gt; hincrby myhash field4 -1 #将键值-1(integer) 5127.0.0.1:6379&gt; hsetnx myhash field5 d #不存在就添加键和值(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;b&quot;3) &quot;fied3&quot;4) &quot;d&quot;5) &quot;field4&quot;6) &quot;5&quot;7) &quot;field5&quot;8) &quot;d&quot;########################################### 总结： hset：创建并初始化值或者修改键值 hmset：功能与hset一致 hmget：同时获取hash多个键的值 hget：获取hash某个键的值 hgetall：获取hash所有的键值 hdel：删除hash某个键 hlen：获取hash长度 hexists：判断hash是否存在键 hkeys：获取hash所有键 hvals：获取hash所有值 hincrby：将hash的一个数值的键值+1，如果为负数则减一 hsetnx：如果不存在就向hash添加键值 5.Zset有序集合类型123456789101112131415161718192021222324252627282930127.0.0.1:6379&gt; zadd myset 1 one #创建并初始化zset或添加元素(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three(integer) 2127.0.0.1:6379&gt; zrange myset 0 -1 #查看所有元素1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;127.0.0.1:6379&gt; zadd myset 10 ten(integer) 1127.0.0.1:6379&gt; zrangebyscore myset -inf +inf #获取根据score增序排列zset1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;4) &quot;ten&quot;127.0.0.1:6379&gt; zrange myset 0 -1 1) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;4) &quot;ten&quot;127.0.0.1:6379&gt; zrem myset ten #删除zset中的某一个元素(integer) 1127.0.0.1:6379&gt; zcard myset #查看zset的长度(integer) 3127.0.0.1:6379&gt; zrevrange myset 0 -1 #获取根据score降序排列的zset1) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; zcount myset 2 3 #查看zset中score在两个数值之间的个数(integer) 2 总结： zadd：创建并初始化zset或添加元素 zrange：获取zset所有元素 zrangebyscore：根据score对zset进行增序排序，可以通过limit显示一部分，withscore显示score值 zrevrange：根据score对zset进行降序排列并显示 zcount：获取zset元素在score两个数值之间的个数 zcard：获取zset的长度 zrem：删除zset中某个元素 6.Geospatial地理位置7.Hyperloglog基数统计8.Bitmap位图场景","categories":[{"name":"数据库","slug":"数据库","permalink":"https://lujaywang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://lujaywang.github.io/tags/redis/"},{"name":"noSql","slug":"noSql","permalink":"https://lujaywang.github.io/tags/noSql/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"spring","slug":"spring","permalink":"https://lujaywang.github.io/categories/spring/"},{"name":"数据库","slug":"数据库","permalink":"https://lujaywang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"java","slug":"java","permalink":"https://lujaywang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://lujaywang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"spring","slug":"spring","permalink":"https://lujaywang.github.io/tags/spring/"},{"name":"MySQL","slug":"MySQL","permalink":"https://lujaywang.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://lujaywang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","permalink":"https://lujaywang.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"redis","slug":"redis","permalink":"https://lujaywang.github.io/tags/redis/"},{"name":"noSql","slug":"noSql","permalink":"https://lujaywang.github.io/tags/noSql/"}]}